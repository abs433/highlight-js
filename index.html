<html>

<head>
    <style>
        .highlight {
            background-color: yellow;
            font-weight: bold;
        }
        #search{
            width: 300px;
            margin: 10px;
        }
        #text{
            text-align: justify;
            padding: 10px;
        }
    </style>
</head>

<body>
    <div style="display: flex; flex-direction: column;text-align: center;align-items: center;">
<h1>
    Searching and Marking
</h1>
abu bakar
<input type="text" id="search" /><button style="width: 100px;" onClick="search(id)" id="button">
    Highlight
</button>

<p id="text">
    What exactly is this Worker thread module, and why do we need it? In this post, we will talk about the historical
    reasons concurrency is implemented in JavaScript and Node.js, the problems we might find, current solutions, and the
    future of parallel processing with Worker threads.

    Living in a single-threaded world
    JavaScript was conceived as a single-threaded programming language that ran in a browser. Being single-threaded
    means that only one set of instructions is executed at any time in the same process (the browser, in this case, or
    just the current tab in modern browsers).

    This made things easier for implementation and for developers using the language. JavaScript was initially a
    language only useful for adding some interaction to webpages, form validations, and so on â€” nothing that required
    the complexity of multithreading.
</p> 
</div>
    <script>

    function search(e) {
        let searched = document.getElementById("search").value.trim();
        if (searched !== "") {
            let text = document.getElementById("text").innerHTML;
            let re = new RegExp(searched, "g"); // search for all instances
            let newText = text.replace(re, `<mark>${searched}</mark>`);
            document.getElementById("text").innerHTML = newText;
        }
    }
    </script>
</body>

</html>